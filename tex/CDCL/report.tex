% !TeX encoding = UTF-8
% !TeX program = xelatex+shellescape
% !TeX spellcheck = LaTeX
%
% Author : Shlw
\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}

\geometry{left=1.5cm,right=1.5cm,top=1.5cm,bottom=2cm}

\title{CDCL Based SAT-Solver}
\author{Kevin Wu\\1600012832}
\date{\today}

\begin{document}
\maketitle
\section{Clarification}
Despite the different algorithm, there are still many similarities between DPLL and CDCL. Many of the fundamental implementation detail are stated in \textbf{DPLL.pdf}. Here, I just specify several difference.\par
I followed \url{https://en.wikipedia.org/wiki/Conflict-Driven_Clause_Learning} instructions to implement this SAT-Solver.

\section{Key Implementation Ideas}
\begin{enumerate}
\setlength{\itemsep}{.1em}
\item \textbf{Main Process:} Quoted from Wikipedia
\begin{center}
Conflict-Driven Clause Learning
\begin{enumerate}
\small\setlength{\itemsep}{.1em}
\item Select a variable and assign True or False. Remember the assignment.
\item Apply Boolean constraint propagation (Unit propagation).
\item Build the implication graph.
\item If there is any conflict then analyze the conflict and non-chronologically backtrack ("back jump") to the appropriate decision level.
\item Otherwise continue from step 1 until all variable values are assigned.
\end{enumerate}
\end{center}
\item \textbf{Set Pure:} Based on the instructions from Wikipedia, there is no \textit{Set Pure} procedure. But this process does no harm to the other parts; so I added this feature in my code like DPLL version.
\item \textbf{Implication Graph:} This graph (DAG) shows how the program determines every literals step by step. Basically, when you do \textit{BCP} and \textit{Set Pure}, add a deduce edge; when you do \textit{Decision}, add a decision edge. This graph is essential in \textit{Conflict Analysis}.
\item \textbf{Conflict Analysis:} This is how program learns to analyze the reason why conflict occurs. Basically, you go from conflict point and back search all the decision points that contribute to this deduction, thus the clause learned. And then add it to the original clause group.\par
Since it is a DAG, in my implication way, I implicitly build the graph, and store this clause when literal was deduced.
\item \textbf{Back Jump:} From the learned clause, the program can jump back to the second latest decision point, for the last one can be determined by BCP after the second latest decision.
\end{enumerate}
\section{Potential Traps}
\begin{enumerate}
\setlength{\itemsep}{.1em}
\item It is worth mentioning that due to the learned clause, you will have to consider how to deal with those eliminated literals (in \textit{Decision}) in the new clause. Because my implementation needs to guarantee every time equation list can not have eliminated literals, I have to maintain the stack manually and insert those literals as eliminated in previous stack level and recover them in recursion.
\item Since \textit{Set Pure} preserves the satisfiability, those literals eliminated by \textit{Set Pure} do not need to draw into \textit{Implication Graph}.
\end{enumerate}
\textbf{Note:} Aside from CDCL based SAT-Solver, I also implemented a DPLL based SAT-Solver, the code and report of which can be found in \url{https://github.com/Shlw/Naive-SAT-Solver}
\end{document}
